Ахмедов Артем, Б05-123

Даны regex и слово word ∈ {a, b, c}
Найти длину самого длинного подслова word, принадлежащего L.


Пусть regex регулярное выражение.
Сопоставим каждому символу regex[j] регулярное выражение regex[i..j], то есть для каждого j мы находим индекс i по следующему правилу:

    если regex - буква, то I(j) := j
    если regex - символ звездочки, то I(j) := I(j - 1)
    если regex - символ умножения или сложения, то I(j) := I(I(j - 1) - 1)

Будем решать задачу динамическим программированием.
Пусть m = regex_size, n = word_size.
Заведём трёхмерный массив dp[0..m)[0..n][0..n] (то есть он будет размерности m(n + 1)^2) со следующим смыслом:
dp[k][i][j] := можно ли получить подслово word[i..j) из регулярного выражения, соответствующего символу regex[k].


Считать его мы будем следующим образом:

    1) если regex[k] - буква, то для всех индексов i таких что word[i] == regex[k] присваиваем dp[k][i][i + 1] = true

    2) если regex[k] - символ сложения, то найдём индексы k_1 и k_2, которые являются операндами для rpn_k.
        Более конкретно k_2 := k - 1, k_1 := I(k - 1) - 1. Тогда присвоим dp[k][i][j] = dp[k_1][i][j] || dp[k_2][i][j].
        Здесь мы говорим, что подслово word[i..j) может быть получено из регулярного выражения, 
        соответствующего regex[k], если оно может быть получено из первого операнда для regex[k] или из второго.

    3) если regex[k] - символ умножения, то аналогично предыдущему пункту найдём индексы k_1 и k_2. 
        Далее переберём все t такие что i <= t <= j и если хотя бы для одного t верно dp[k_1][i][t] && dp[k_2][t][j], 
        то присвоим dp[k][i][j] = true. Здесь мы говорим, что подслово word[i..j) может быть получено из регулярного 
        выражения, соответствующего regex[k], если существует разбиение этого слова на два слова: 
        word[i..j) = word[i..t) + word[t..j) и каждое из этих двух слов может быть получено из соответствующих 
        операндов для regex[k].

    4) если regex[k] - символ звёздочки, то найдём индекс k_0, который является операндом для regex[k].
        Более конкретно k_0 := k - 1. Далее переберём все t такие что i <= t <= j и если хотя бы для одного t верно 
        dp[k][i][t] && dp[k_0][t][j], то присвоим dp[k][i][j] = true.
        Здесь мы говорим, что подслово word[i..j) может быть получено из РВ для regex[k], если существует разбиение 
        этого слова на несколько слов: word[i..j) = word[i..i_1) + word[i_1..i_2) ... word[i_l..j) 
        и каждое из этих слов может быть получено из РВ для regex[k_0]. Это в свою очередь эквивалентно тому, 
        что существует разбиение слова word[i..j) на два слова: word[i..j) = word[i..i_l) + word[i_l..j) и первое слово
        может быть получено из РВ для regex[k], а второе из РВ для regex[k_0].

